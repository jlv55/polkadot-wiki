"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[2706],{55564:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"learn/learn-comparisons","title":"Polkadot Comparisons","description":"Comparison between Polkadot and other Networks.","source":"@site/../docs/learn/learn-comparisons.md","sourceDirName":"learn","slug":"/learn-comparisons","permalink":"/docs/learn-comparisons","draft":false,"unlisted":false,"editUrl":"https://github.com/w3f/polkadot-wiki/edit/master/docs/learn/learn-comparisons.md","tags":[],"version":"current","lastUpdatedBy":"Filippo","lastUpdatedAt":1736502578000,"frontMatter":{"id":"learn-comparisons","title":"Polkadot Comparisons","sidebar_label":"Comparisons","description":"Comparison between Polkadot and other Networks.","keywords":["comparisons","Polkadot","blockchain","rollups","polkadot","scalability","shared","security","parachain","ethereum"],"slug":"../learn-comparisons"},"sidebar":"docs","previous":{"title":"XCM Glossary","permalink":"/docs/learn/xcm/reference-glossary"},"next":{"title":"Kusama","permalink":"/docs/learn-comparisons-kusama"}}');var s=n(74848),r=n(28453),a=n(99563);const o={id:"learn-comparisons",title:"Polkadot Comparisons",sidebar_label:"Comparisons",description:"Comparison between Polkadot and other Networks.",keywords:["comparisons","Polkadot","blockchain","rollups","polkadot","scalability","shared","security","parachain","ethereum"],slug:"../learn-comparisons"},l=void 0,c={},d=[{value:"Rollup Comparison",id:"rollup-comparison",level:2},{value:"Fraud Proofs vs. Validity Proofs",id:"fraud-proofs-vs-validity-proofs",level:3},{value:"Zero-knowledge Rollups",id:"zero-knowledge-rollups",level:3},{value:"Optimistic Rollups",id:"optimistic-rollups",level:3},{value:"Polkadot Rollups",id:"polkadot-rollups",level:3},{value:"Rollup Comparison Table",id:"rollup-comparison-table",level:3},{value:"Interoperability Comparison",id:"interoperability-comparison",level:2},{value:"Other Comparisons",id:"other-comparisons",level:2}];function h(e){const i={a:"a",admonition:"admonition",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.h2,{id:"rollup-comparison",children:"Rollup Comparison"}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Rollups"}),' are an L2 scaling solution. At the most basic level, a rollup L2 solution is responsible\nfor "rolling up" transactions by batching them before publishing them to the L1 chain, usually\nthrough a network of ',(0,s.jsx)(i.strong,{children:"sequencers"}),". In theory, separate entities could assume the role of\nsequencing transactions and publishing them. In practice, they are the same machine, but this will\nlikely change as rollups decentralize more. This mechanism could include thousands of transactions\nin a single rollup."]}),"\n",(0,s.jsxs)(i.admonition,{title:"Layer Two Definition",type:"info",children:[(0,s.jsx)(i.p,{children:"Layer two (L2) networks are a key approach to blockchain scalability, off-loading the majority of\ncomputation from layer one (L1) networks. These solutions leverage the security of L1 to create an\nadditional layer that is faster, reduces fees, and addresses platform-specific challenges. L2\nsolutions also focus on utilizing L1 blockspace efficiently and cost-effectively."}),(0,s.jsxs)(i.p,{children:["By adopting modular designs and re-using functionality, L2 networks enable the deployment of\nscalable rollups for various virtual machine environments, including Ethereum Virtual Machine (EVM),\nSolana Virtual Machine (SVM) and ",(0,s.jsx)(i.a,{href:"https://move-language.github.io/move/",children:"Move-based"})," systems. These\nrollups settle back to Ethereum, ensuring a robust and secure foundation for diverse blockchain\necosystems."]})]}),"\n",(0,s.jsx)(i.p,{children:"In this section, we explore the main differences in rollup technology between:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Zero-knowledge rollups,"}),"\n",(0,s.jsx)(i.li,{children:"Optimistic rollups, and"}),"\n",(0,s.jsx)(i.li,{children:"Polkadot rollups (i.e., parachains)."}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"Before diving into the differences between these rollup technologies, it is crucial to understand\nthe difference between non-interactive and interactive methods."}),"\n",(0,s.jsx)(i.h3,{id:"fraud-proofs-vs-validity-proofs",children:"Fraud Proofs vs. Validity Proofs"}),"\n",(0,s.jsxs)(i.p,{children:["In the context of rollups, ",(0,s.jsx)(i.strong,{children:"interactive"})," and ",(0,s.jsx)(i.strong,{children:"non-interactive"})," methods are commonly used to\ndescribe how the validity of transactions or state changes is established between the rollup layer\nand the main blockchain (L1). These terms correspond closely to the mechanisms of ",(0,s.jsx)(i.strong,{children:"fraud proofs"}),"\nand ",(0,s.jsx)(i.strong,{children:"validity proofs"}),", which are the standard terminology."]}),"\n",(0,s.jsxs)(i.p,{children:["An ",(0,s.jsx)(i.strong,{children:"interactive method"}),' (associated with fraud proofs) involves a back-and-forth process to\nvalidate transactions. A "prover" submits transaction data or state changes to L1, assuming it is\nvalid. A challenge mechanism is triggered if a dispute arises, requiring participants to provide\nevidence (fraud proofs) to demonstrate invalidity. This process ensures correctness but introduces\nlatency due to dispute resolution periods, which can vary depending on the implementation. For\nexample, optimistic rollups often have challenge periods of several hours or even up to seven days.']}),"\n",(0,s.jsxs)(i.p,{children:["A ",(0,s.jsx)(i.strong,{children:"non-interactive method"})," (associated with validity proofs) relies on cryptographic mechanisms,\nsuch as SNARKs or STARKs, to validate transactions upfront. These proofs are generated off-chain and\nsubmitted to L1 for verification without requiring dispute resolution. While these methods offer\nnear-instant finality, in theory, in practice delays are sometimes intentionally introduced as\nsafeguards. For instance, zkSync rollups may take up to a day to finalize transactions, not due to\ntechnical limitations but as a precautionary measure while the technology matures and secures\nhigh-value assets."]}),"\n",(0,s.jsx)(i.p,{children:"Below is a comparison of the two mechanisms:"}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:(0,s.jsx)(i.strong,{children:"Aspect"})}),(0,s.jsx)(i.th,{children:(0,s.jsx)(i.strong,{children:"Fraud Proofs (Interactive)"})}),(0,s.jsx)(i.th,{children:(0,s.jsx)(i.strong,{children:"Validity Proofs (Non-Interactive)"})})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Mechanism"})}),(0,s.jsx)(i.td,{children:"Challenge-based system where disputes are resolved interactively."}),(0,s.jsx)(i.td,{children:"Cryptographic proofs validate all transactions upfront, eliminating disputes."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Latency"})}),(0,s.jsx)(i.td,{children:"Time to finality depends on challenge periods. Optimistic rollups often take hours or even days to finalize. Polkadot rollups reduce this to around 30 minutes."}),(0,s.jsx)(i.td,{children:"Near-instant finality in theory. In practice, systems like zkSync can take up to a day to finalize, often due to artificial safeguards rather than inherent technical limitations."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Security Basis"})}),(0,s.jsx)(i.td,{children:"Crypto-economic incentives and participant monitoring ensure validity."}),(0,s.jsx)(i.td,{children:"Cryptographic guarantees ensure correctness upfront, reducing the need for external monitoring."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Complexity"})}),(0,s.jsx)(i.td,{children:"Simpler to implement but requires active monitoring and challenge resolution."}),(0,s.jsx)(i.td,{children:"Computationally intensive and complex to build, especially for ZK systems."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Use Cases"})}),(0,s.jsx)(i.td,{children:"Suitable for applications needing broad compatibility with existing systems and tolerating some latency for finality."}),(0,s.jsx)(i.td,{children:"Ideal for high-security applications or scenarios where upfront validation and near-instant finality are critical."})]})]})]}),"\n",(0,s.jsx)(i.p,{children:"Both approaches address different trade-offs between scalability, security, latency, and\nimplementation complexity. Future innovations may blur the lines between these mechanisms, enabling\nhybrid approaches such as non-interactive dispute systems."}),"\n",(0,s.jsx)(i.h3,{id:"zero-knowledge-rollups",children:"Zero-knowledge Rollups"}),"\n",(0,s.jsx)(i.p,{children:'Zero-knowledge rollups (commonly referred to as ZK rollups) are a non-interactive method that\nutilizes cryptographic proofs, often in the form of SNARKs, to compute the validity of a particular\nset of state changes. While the industry has adopted the term "ZK rollups," it is worth noting that\nmany implementations do not strictly involve zero-knowledge properties, as the proofs do not\nnecessarily conceal information. These rollups are better described simply as SNARK-based rollups,\nbut the term "ZK rollups" remains widely used.'}),"\n",(0,s.jsxs)(i.p,{children:["In contrast to ",(0,s.jsx)(i.a,{href:"#optimistic-rollups",children:"optimistic rollups"}),", which rely on fraud proofs and interactive\nchallenge mechanisms, ZK rollups rely entirely on cryptographic validation, with SNARKs providing\nupfront proof of correctness. This approach allows ZK rollups to achieve significantly faster\nfinalization, as the validity proof ensures that all state transitions are correct without requiring\na challenge period."]}),"\n",(0,s.jsxs)(i.p,{children:["However, ZK rollups face performance challenges due to the computational complexity involved in\nproof generation and the difficulty of implementing these proofs in resource-constrained\nenvironments. This complexity also makes achieving Turing completeness more challenging, which can\nlimit their generalizability in terms of blockspace usage. Despite these challenges, ZK rollups are\nbecoming increasingly viable for specialized applications. For example,\n",(0,s.jsx)(i.a,{href:"/docs/learn-bridges#bridge-comparison",children:"Hyperbridge"})," is a SNARK-based rollup on Polkadot that acts as\na scalable, trustless bridge. It produces a single proof for multiple blockchains, which can be\ninstantly verified on Polkadot, demonstrating the potential of these rollups in niche use cases."]}),"\n",(0,s.jsx)(i.h3,{id:"optimistic-rollups",children:"Optimistic Rollups"}),"\n",(0,s.jsxs)(i.p,{children:["Optimistic rollups are an interactive scaling method for L1 blockchains. They assume\n",(0,s.jsx)(i.em,{children:"optimistically"})," that every proposed transaction is valid by default."]}),"\n",(0,s.jsxs)(i.p,{children:["In the case of mitigating potentially invalid transactions, optimistic rollups introduce a\n",(0,s.jsx)(i.em,{children:"challenge period"})," during which participants may challenge a suspect rollup. A fraud-proving scheme\ncan be in place to allow for several ",(0,s.jsx)(i.em,{children:"fraud proofs"})," to be submitted. Those proofs could make the\nrollup valid or invalid. State changes may be disputed, resolved, or included during the challenge\nperiod if no challenge is presented (and the required proofs are in place)."]}),"\n",(0,s.jsxs)(i.p,{children:["Optimistic rollups are often used in the Ethereum ecosystem. ",(0,s.jsx)(i.a,{href:"https://www.optimism.io/",children:"Optimism"}),"\nand ",(0,s.jsx)(i.a,{href:"https://bridge.arbitrum.io/",children:"Arbitrium"})," are an example of optimistic EVM-based rollups."]}),"\n",(0,s.jsx)(i.h3,{id:"polkadot-rollups",children:"Polkadot Rollups"}),"\n",(0,s.jsxs)(i.p,{children:["Polkadot Rollups work similarly to optimistic rollups. They are an interactive method with fraud\nproof mechanism. Like optimistic rollups and zk rollups are secured by Ethereum, Polkadot rollups\nare secured by the Polkadot Relay Chain. The checking and fraud-proof mechanics are natively\nimplemented in Polkadot. ",(0,s.jsx)(i.a,{href:"/docs/learn-collator",children:"Collators"})," are in principle similar to sequencers, as\nthey pass data with a proof-of-validity (PoV) function for liveness and communication with the Relay\nChain."]}),"\n",(0,s.jsxs)(i.p,{children:["Additionally, Polkadot operates as a ",(0,s.jsx)(i.em,{children:"stateless client"})," of its rollups, meaning the Relay Chain does\nnot maintain the entire state of each parachain. Instead, it verifies state transitions using PoV\nblocks submitted by collators. This is analogous to ",(0,s.jsx)(i.em,{children:"block witnesses"})," in the Ethereum ecosystem,\nwhich proves transaction validity without requiring full state storage. This design ensures\nscalability by delegating state maintenance to rollups while enabling secure validation through\ncryptographic proofs."]}),"\n",(0,s.jsx)(i.p,{children:"Polkadot rollups have the following main differences compared to optimistic rollups:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["Polkadot implements rollup functionality at the native level (i.e., without using L2 scaling\nsolutions), allowing for shared security and scalability for each rollup through the\n",(0,s.jsx)(i.a,{href:"/docs/learn-parachains-protocol",children:"Parachains Protocol"}),". Polkadot handles data coordination from\nparachains into an aggregated, representative state, similar to L2 rollups."]}),"\n",(0,s.jsxs)(i.li,{children:["If optimistic rollups are based on the assumption that all transactions are valid, ",(0,s.jsx)(i.strong,{children:'Polkadot\nrollups are "cynical" and always check the validity of transactions using a subset of the\nvalidators'}),". In case of disputes, an escalation effect involving more validators is triggered,\nand dispute resolution will end with the malicious actor being ",(0,s.jsx)(i.a,{href:"/docs/learn-offenses",children:"slashed"}),"."]}),"\n",(0,s.jsxs)(i.li,{children:["Polkadot has multiple virtual cores that are made possible thanks to the Parachain Protocol, which\nallows execution sharding. Rollups access Polkadot by reserving time on those cores via\n",(0,s.jsx)(i.a,{href:"/docs/learn-agile-coretime",children:"coretime"}),"."]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"A more detailed comparison of Polkadot rollups with optimistic and zk rollups can be found in the\ncomparison table below."}),"\n",(0,s.jsx)(i.h3,{id:"rollup-comparison-table",children:"Rollup Comparison Table"}),"\n",(0,s.jsxs)(i.p,{children:["Here below there is a comparison table summarizing the main differences between Polkadot, ZK, and\nOptimistic rollups. An in-depth comparison between different types of optimistic and ZK rollups can\nbe found on ",(0,s.jsx)(i.a,{href:"https://l2beat.com/scaling/summary",children:"l2beat"}),"."]}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:(0,s.jsx)(i.strong,{children:"Feature"})}),(0,s.jsx)(i.th,{children:(0,s.jsx)(i.strong,{children:"ZK Rollups"})}),(0,s.jsx)(i.th,{children:(0,s.jsx)(i.strong,{children:"Optimistic Rollups"})}),(0,s.jsx)(i.th,{children:(0,s.jsx)(i.strong,{children:"Polkadot Parachains/Rollups"})})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Finality"})}),(0,s.jsx)(i.td,{children:"Near-instant finality. Because the proof is immediately available, finality is also instantaneous."}),(0,s.jsx)(i.td,{children:"Delayed finality (a week) due to fraud-proof mechanisms."}),(0,s.jsx)(i.td,{children:"Fast finality (under 1 minute) via relay chain consensus."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Security Model"})}),(0,s.jsx)(i.td,{children:"Relies on cryptographic validity proofs, ensuring high security and no reliance on game-theoretic assumptions."}),(0,s.jsx)(i.td,{children:"Relies on economic incentives and a challenge period to catch fraud. Optimistic assumption makes it less secure than ZK Rollups."}),(0,s.jsx)(i.td,{children:'"Cynical" model, where every transaction is checked by a subset of validators, with escalation and slashing in case of disputes.'})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Scalability"})}),(0,s.jsx)(i.td,{children:"Limited scalability as they are a single state machine and are only as scalable as the prover machine and computation requirement. Many zk-rollups disable cryptographic precompiles on the mainnet as a result of the immense computational requirement for them."}),(0,s.jsx)(i.td,{children:"High, with parallelization, but limited by gas costs on L1 chains like Ethereum."}),(0,s.jsxs)(i.td,{children:["Inherently scalable through native execution sharding and parachains operating in parallel. ",(0,s.jsx)(i.a,{href:"/docs/learn-async-backing",children:"Pipelining"})," and ",(0,s.jsx)(i.a,{href:"/docs/learn-agile-coretime",children:"core scheduling"})," increase throughput and scalability for the single rollup. Execution sharding is enabled by multiple virtual cores using ",(0,s.jsx)(i.a,{href:"/docs/learn-agile-coretime",children:"coretime"}),"."]})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Interoperability"})}),(0,s.jsxs)(i.td,{children:["Limited interoperability",(0,s.jsx)("sup",{children:"1"}),", often restricted to compatible L1s."]}),(0,s.jsxs)(i.td,{children:["Limited interoperability",(0,s.jsx)("sup",{children:"1"}),", often confined to the parent blockchain ecosystem. See the ",(0,s.jsx)(i.a,{href:"#interoperability-comparison",children:"comparison about interoperability"})," for more information."]}),(0,s.jsxs)(i.td,{children:["Native interoperability through ",(0,s.jsx)(i.a,{href:"/docs/learn-xcm",children:"XCM"}),", allowing seamless communication between parachains having different logic. ",(0,s.jsx)(i.a,{href:"/docs/learn-bridges",children:"Trustless bridges"})," can connect Polkadot to other blockchains."]})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"State Transition Logic"})}),(0,s.jsx)(i.td,{children:"General-purpose but constrained by zk-circuit implementation complexity."}),(0,s.jsxs)(i.td,{children:["Can support state transitions beyond EVM compatibility by interpreting other virtual machine (VM) logic within the EVM environment",(0,s.jsx)("sup",{children:"2"}),"."]}),(0,s.jsx)(i.td,{children:"Each parachain can define its unique state transition function (STF), which is compiled to Wasm and validated per Parachain Protocol rules."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Development Complexity"})}),(0,s.jsx)(i.td,{children:"Complex due to the mathematics of zero-knowledge proofs."}),(0,s.jsx)(i.td,{children:"Moderate complexity, requiring fraud-proof implementation."}),(0,s.jsx)(i.td,{children:"Moderate to high complexity; parachain runtimes must be written in WASM-compatible languages but can define custom logic and governance. Parachain maintenance can be an overhead."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Data Availability"})}),(0,s.jsx)(i.td,{children:"Data availability requirements posted by the optimistic and ZK rollups are the same."}),(0,s.jsx)(i.td,{children:"Data availability requirements posted by the optimistic and ZK rollups are the same."}),(0,s.jsx)(i.td,{children:"Built-in data availability with validators ensuring distributed state storage and reconstruction in case of disputes."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Cost Efficiency"})}),(0,s.jsx)(i.td,{children:"High efficiency but expensive prover computation."}),(0,s.jsx)(i.td,{children:"More cost-effective but susceptible to congestion during high usage."}),(0,s.jsx)(i.td,{children:"Cost-effective as parachains are independently scalable and not tied to L1 gas fees."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Governance Upgrades"})}),(0,s.jsx)(i.td,{children:"Subject to parent chain governance."}),(0,s.jsx)(i.td,{children:"Governed by parent L1 network governance."}),(0,s.jsx)(i.td,{children:"Forkless upgrades are supported through Polkadot\u2019s native governance mechanisms."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Fraud/Validity Proofs"})}),(0,s.jsx)(i.td,{children:"Non-interactive validity proofs, ensuring correctness off-chain."}),(0,s.jsx)(i.td,{children:"Fraud proofs requiring active challenges during the dispute window."}),(0,s.jsx)(i.td,{children:"Continuous validity checks by validators with dispute escalation effects, ending in slashing malicious actors."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Applications"})}),(0,s.jsx)(i.td,{children:"Ideal for high-security use cases like financial transactions and privacy-preserving applications."}),(0,s.jsx)(i.td,{children:"Suitable for general-purpose dApps with moderate security needs."}),(0,s.jsx)(i.td,{children:"Fully-fledged state machines capable of defining governance, logic, and custom runtime environments, ideal for diverse blockchain apps."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsxs)(i.td,{children:[(0,s.jsx)(i.strong,{children:"Escape Hatch"}),(0,s.jsx)("sup",{children:"3"})]}),(0,s.jsx)(i.td,{children:"No built-in escape hatch; relies on zk circuits functioning correctly."}),(0,s.jsx)(i.td,{children:"Can include an escape hatch to withdraw funds if sequencers fail."}),(0,s.jsx)(i.td,{children:"No native escape mechanism; funds could be trapped if parachain collators fail."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Permissioning"})}),(0,s.jsx)(i.td,{children:"Typically relies on permissioned sequencers."}),(0,s.jsx)(i.td,{children:"Sequencers can be permissioned or partially permissionless."}),(0,s.jsx)(i.td,{children:"Parachains support permissioned and permissionless collator sets, providing flexibility for private or public use cases."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Shared Security"})}),(0,s.jsx)(i.td,{children:"Relies on the parent chain's security guarantees, leveraging zk-proofs."}),(0,s.jsx)(i.td,{children:"Security shared with the L1 via fraud-proof mechanisms."}),(0,s.jsx)(i.td,{children:"Security shared with the Relay Chain via Parachian Protocol."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Sharding"})}),(0,s.jsx)(i.td,{children:"Only data sharding. Execution sharding does not apply to Ethereum ZK rollups."}),(0,s.jsx)(i.td,{children:"Only data sharding. Execution sharding does not apply to Ethereum Optimistic rollups."}),(0,s.jsx)(i.td,{children:"Data sharding and execution sharding enabled through the Parachain Protocol, leveraging multiple virtual cores and reserving coretime for rollup operations."})]})]})]}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)("sup",{children:"1"}),'There are efforts to allow native interoperability within rollup hubs, e.g., there will\nbe "better" interoperability within the OP Stack ecosystem than independent L2s.']}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)("sup",{children:"2"}),"Optimistic rollups rely on Ethereum's EVM (Ethereum Virtual Machine) for their\nfraud-proof mechanisms and dispute resolution. However, rather than natively executing L2 opcodes,\nthe EVM interprets the logic of the rollup's virtual machine."]}),"\n",(0,s.jsx)(i.admonition,{title:"Opcodes",type:"info",children:(0,s.jsx)(i.p,{children:"An opcode (short for operation code) is the fundamental instruction used by a virtual machine to\nperform specific operations. In the context of the EVM, opcodes define low-level commands that\nexecute computations, manage storage, and interact with smart contracts. Rollups process their\nopcodes, which the EVM interprets during dispute resolution and other operations."})}),"\n",(0,s.jsx)(i.p,{children:"While optimistic rollups often support EVM-compatible state transitions for seamless integration\nwith Ethereum and its ecosystem, they are not inherently restricted to EVM logic. Developers could\nimplement interpretation logic for other virtual machines, such as WASM or custom environments,\nenabling optimistic rollups to support diverse computational frameworks. This flexibility expands\ntheir potential beyond traditional EVM-based boundaries, contrasting with the perception that they\nare strictly tied to Ethereum\u2019s computational model."}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)("sup",{children:"3"}),"An escape hatch is a method by which users of a rollup can recover digital assets or\nprogram state from a rollup when the operators (sequencers) are offline."]}),"\n",(0,s.jsx)(i.h2,{id:"interoperability-comparison",children:"Interoperability Comparison"}),"\n",(0,s.jsxs)(i.p,{children:["In this section, we explore the main differences in interoperability between Polkadot,\n",(0,s.jsx)(i.a,{href:"https://docs.optimism.io/stack/explainer",children:"Optimism Superchain Ecosystem"})," and\n",(0,s.jsx)(i.a,{href:"https://chain.link/cross-chain",children:"Chainlink CCIP (Cross-chain Interoperability Protocol)"}),"."]}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Feature"}),(0,s.jsx)(i.th,{children:"Polkadot XCM"}),(0,s.jsx)(i.th,{children:"Optimism Superchain Interoperability"}),(0,s.jsx)(i.th,{children:"Chainlink CCIP"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Architecture"})}),(0,s.jsx)(i.td,{children:"Direct communication between parachains within the Polkadot ecosystem using a unified relay chain."}),(0,s.jsx)(i.td,{children:"Cross-rollup interoperability built on Ethereum, extending rollups\u2019 compatibility."}),(0,s.jsx)(i.td,{children:"Universal standard enabling cross-chain communication for any blockchain network."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Scope"})}),(0,s.jsx)(i.td,{children:"Limited to parachains and relay chains in the Polkadot/Kusama ecosystem."}),(0,s.jsx)(i.td,{children:"Focused on rollups in Ethereum Layer 2 (e.g., Optimism, Base)."}),(0,s.jsx)(i.td,{children:"Blockchain-agnostic, supporting public and private chains."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Consensus Dependency"})}),(0,s.jsx)(i.td,{children:"Relies on Polkadot's shared relay chain consensus."}),(0,s.jsx)(i.td,{children:"Depends on Ethereum Layer 1 for security and sequencer trust within Superchain rollups."}),(0,s.jsx)(i.td,{children:"Independent of any specific chain\u2019s consensus, it uses an oracle network for secure messaging."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Interoperability Model"})}),(0,s.jsx)(i.td,{children:"Messages are trustlessly passed between parachains using XCMP and HRMP channels."}),(0,s.jsx)(i.td,{children:"Rollups communicate through the Superchain\u2019s sequencer infrastructure."}),(0,s.jsx)(i.td,{children:"Relies on Chainlink decentralized oracles to transmit data securely across chains."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Scalability"})}),(0,s.jsx)(i.td,{children:"High scalability within the ecosystem; limited by relay chain capacity."}),(0,s.jsx)(i.td,{children:"Limited by Ethereum throughput and Superchain architecture."}),(0,s.jsx)(i.td,{children:"Scalable; offloads cross-chain messaging to oracle networks."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Security Model"})}),(0,s.jsx)(i.td,{children:"Secured by Polkadot's relay validators and stake."}),(0,s.jsx)(i.td,{children:"Secured by Ethereum\u2019s base layer and rollup-specific fraud or validity proofs."}),(0,s.jsx)(i.td,{children:"Security ensured by Chainlink oracles and cryptographic proofs."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Ease of Integration"})}),(0,s.jsx)(i.td,{children:"Requires Substrate-based parachains and compliance with Polkadot protocols."}),(0,s.jsx)(i.td,{children:"Requires rollups to align with Optimism\u2019s OP stack architecture."}),(0,s.jsx)(i.td,{children:"Blockchain-agnostic, integrates with any chain using CCIP libraries."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Interoperability Speed"})}),(0,s.jsx)(i.td,{children:"Near-instant, as Polkadot\u2019s shared relay chain validates interactions."}),(0,s.jsx)(i.td,{children:"Relatively slower due to dependency on Layer 1 Ethereum finality and rollup delays."}),(0,s.jsx)(i.td,{children:"Fast, as it relies on Chainlink oracle nodes for data transmission."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Use Cases"})}),(0,s.jsx)(i.td,{children:"Native token transfers, contract execution (though Polkadot allows smart contract execution through XCM, it is almost impossible to use trustlessly in practice, as only straightforward calls can be passed without read access), and shared staking pools."}),(0,s.jsx)(i.td,{children:"Bridging assets and state between rollups."}),(0,s.jsx)(i.td,{children:"Cross-chain DeFi, gaming, enterprise blockchain communication."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Prone to Centralization"})}),(0,s.jsx)(i.td,{children:"Low; while Polkadot's design enforces decentralization, it allows the decentralization of collators but does not mandate it, as there are chains with teams operating all collators."}),(0,s.jsx)(i.td,{children:"Optimism does not currently give a choice; sequencers must be centralized."}),(0,s.jsx)(i.td,{children:"Depends on the decentralization level of Chainlink's oracle network."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Current Deployment"})}),(0,s.jsx)(i.td,{children:"Actively deployed in Polkadot and Kusama ecosystems."}),(0,s.jsx)(i.td,{children:"Early stage; foundational elements are live, expanding with OP stack rollups."}),(0,s.jsx)(i.td,{children:"Widely adopted across multiple chains in both testnet and mainnet."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Key Strengths"})}),(0,s.jsx)(i.td,{children:"Seamless, low-latency native communication within the ecosystem."}),(0,s.jsx)(i.td,{children:"Interoperability focused on Ethereum scalability and Layer 2 adoption."}),(0,s.jsx)(i.td,{children:"Universal, chain-agnostic standard with flexible use cases."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Limitations"})}),(0,s.jsx)(i.td,{children:"Limited to Polkadot-compatible parachains."}),(0,s.jsx)(i.td,{children:"Restricted to Ethereum and rollups using OP stack."}),(0,s.jsx)(i.td,{children:"It depends on the oracle network security and adoption rate."})]})]})]}),"\n",(0,s.jsx)(i.h2,{id:"other-comparisons",children:"Other Comparisons"}),"\n",(0,s.jsx)(a.A,{})]})}function p(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},99563:(e,i,n)=>{n.d(i,{A:()=>j});n(96540);var t=n(34164),s=n(93751),r=n(56289),a=n(81430),o=n(22887),l=n(50539),c=n(9303);const d={cardContainer:"cardContainer_fWXF",cardTitle:"cardTitle_rnsV",cardDescription:"cardDescription_PWke"};var h=n(74848);function p(e){var i=e.href,n=e.children;return(0,h.jsx)(r.A,{href:i,className:(0,t.A)("card padding--lg",d.cardContainer),children:n})}function u(e){var i=e.href,n=e.icon,s=e.title,r=e.description;return(0,h.jsxs)(p,{href:i,children:[(0,h.jsxs)(c.A,{as:"h2",className:(0,t.A)("text--truncate",d.cardTitle),title:s,children:[n," ",s]}),r&&(0,h.jsx)("p",{className:(0,t.A)("text--truncate",d.cardDescription),title:r,children:r})]})}function m(e){var i,n,t=e.item,r=(0,s.Nr)(t),o=(n=(0,a.W)().selectMessage,function(e){return n(e,(0,l.T)({message:"1 item|{count} items",id:"theme.docs.DocCard.categoryDescription.plurals",description:"The default description for a category card in the generated index about how many items this category includes"},{count:e}))});return r?(0,h.jsx)(u,{href:r,icon:"\ud83d\uddc3\ufe0f",title:t.label,description:null!=(i=t.description)?i:o(t.items.length)}):null}function x(e){var i,n,t=e.item,r=(0,o.A)(t.href)?"\ud83d\udcc4\ufe0f":"\ud83d\udd17",a=(0,s.cC)(null!=(i=t.docId)?i:void 0);return(0,h.jsx)(u,{href:t.href,icon:r,title:t.label,description:null!=(n=t.description)?n:null==a?void 0:a.description})}function f(e){var i=e.item;switch(i.type){case"link":return(0,h.jsx)(x,{item:i});case"category":return(0,h.jsx)(m,{item:i});default:throw new Error("unknown item type "+JSON.stringify(i))}}function g(e){var i=e.className,n=(0,s.$S)();return(0,h.jsx)(j,{items:n.items,className:i})}function j(e){var i=e.items,n=e.className;if(!i)return(0,h.jsx)(g,Object.assign({},e));var r=(0,s.d1)(i);return(0,h.jsx)("section",{className:(0,t.A)("row",n),children:r.map((function(e,i){return(0,h.jsx)("article",{className:"col col--6 margin-bottom--lg",children:(0,h.jsx)(f,{item:e})},i)}))})}},81430:(e,i,n)=>{n.d(i,{W:()=>c});var t=n(96540),s=n(40797),r=["zero","one","two","few","many","other"];function a(e){return r.filter((function(i){return e.includes(i)}))}var o={locale:"en",pluralForms:a(["one","other"]),select:function(e){return 1===e?"one":"other"}};function l(){var e=(0,s.A)().i18n.currentLocale;return(0,t.useMemo)((function(){try{return i=e,n=new Intl.PluralRules(i),{locale:i,pluralForms:a(n.resolvedOptions().pluralCategories),select:function(e){return n.select(e)}}}catch(t){return console.error('Failed to use Intl.PluralRules for locale "'+e+'".\nDocusaurus will fallback to the default (English) implementation.\nError: '+t.message+"\n"),o}var i,n}),[e])}function c(){var e=l();return{selectMessage:function(i,n){return function(e,i,n){var t=e.split("|");if(1===t.length)return t[0];t.length>n.pluralForms.length&&console.error("For locale="+n.locale+", a maximum of "+n.pluralForms.length+" plural forms are expected ("+n.pluralForms.join(",")+"), but the message contains "+t.length+": "+e);var s=n.select(i),r=n.pluralForms.indexOf(s);return t[Math.min(r,t.length-1)]}(n,i,e)}}}},28453:(e,i,n)=>{n.d(i,{R:()=>a,x:()=>o});var t=n(96540);const s={},r=t.createContext(s);function a(e){const i=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(r.Provider,{value:i},e.children)}}}]);